#pragma kernel Initialize
#pragma kernel Update
#pragma kernel MakeParticleGridPair
#pragma kernel Debug
#pragma kernel RearrangeParticle
#pragma kernel MakeGridLookUpTable
#pragma kernel ResetGridLookUpTable

#define BITONIC_BLOCK_SIZE 512
#define TRANSPOSE_BLOCK_SIZE 16

#include "../cginc/GridUtility.cginc"

int _BoundaryXMin;
int _BoundaryXMax;
int _BoundaryYMin;
int _BoundaryYMax;
int _GridNumX;
int _GridNumY;
float _TargetInWorldX;
float _TargetInWorldY;
int _ParticleNum;
int _TargetIndex;


struct Particle
{
    float3 position;
    float3 color;
};
RWStructuredBuffer<Particle> _ParticleBuffer;
StructuredBuffer<Particle> _ReadParticleBuffer;

RWStructuredBuffer<uint2> _ParticleGridPair;
RWStructuredBuffer<uint2> _GridTable;


float random(float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453123);
}

[numthreads(8,1,1)]
void Initialize(uint3 id : SV_DispatchThreadID)
{
    Particle p = _ParticleBuffer[id.x];
    float spacingX = (_BoundaryXMax - _BoundaryXMin) / (float)_GridNumX;
    float spacingY = (_BoundaryYMax - _BoundaryYMin) / (float)_GridNumY;

   /* float posX = (id.x % _GridNumX) * spacingX + spacingX * 0.5f;
    float posY = floor(id.x / _GridNumX) * spacingY + spacingY * 0.5f; */
    float posX = _BoundaryXMin + random(float2(id.x, id.x % _GridNumX)) * (_BoundaryXMax - _BoundaryXMin);
    float posY = _BoundaryYMin + random(float2(id.x / _GridNumY, id.x)) * (_BoundaryYMax - _BoundaryYMin);
    p.position = float3(posX, posY, 0);
    p.color = float3(0, 1, 0);
    _ParticleBuffer[id.x] = p;
}

[numthreads(8, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    int targetIdx = max(0, min(_TargetIndex, _ParticleNum - 1));
    if (id.x != targetIdx) return;

    float spacingX = (_BoundaryXMax - _BoundaryXMin) / (float)_GridNumX;
    float spacingY = (_BoundaryYMax - _BoundaryYMin) / (float)_GridNumY;
    float3 pos = _ParticleBuffer[targetIdx].position;
    uint2 grid = PositionToGrid(pos, float2(spacingX, spacingY));

    int gid = GridToGridID(grid, _GridNumX);
    int start = _GridTable[gid].x;
    int end = _GridTable[gid].y;

    for (int i = start; i <= end; i++)
        _ParticleBuffer[i].color = float3(0, 0, 1);

    //for (int y = max(0, grid.y - 1); y <= min(grid.y + 1, _GridNumY - 1); y++)
    //{
    //    for (int x = max(0, grid.x - 1); x <= min(grid.x + 1, _GridNumX - 1); x++)
    //    {
    //        int gid = GridToGridID(uint2(x, y), _GridNumX);
    //        int start = _GridTable[gid].x;
    //        int end = _GridTable[gid].y;
    //        
    //        if (gid == GridToGridID(grid, _GridNumX))
    //        {
    //            for (int i = start; i <= end; i++)
    //                _ParticleBuffer[i].color = float3(1, 0, 0);
    //        }
    //        else 
    //        {
    //            for (int i = start; i <= end; i++)
    //                _ParticleBuffer[i].color = float3(0, 0, 1);
    //        }
    //    }
    //}
}

[numthreads(8, 1, 1)]
void MakeParticleGridPair(uint3 id : SV_DispatchThreadID)
{
    Particle p = _ParticleBuffer[id.x];
    float spacingX = (_BoundaryXMax - _BoundaryXMin) / (float)_GridNumX;
    float spacingY = (_BoundaryYMax - _BoundaryYMin) / (float)_GridNumY;
    uint2 grid = PositionToGrid(p.position, float2(spacingX, spacingY));
    uint gridID = GridToGridID(grid, _GridNumX);
    _ParticleGridPair[id.x] = uint2(gridID, id.x);
}

[numthreads(8, 8, 1)]
void ResetGridLookUpTable(uint3 id : SV_DispatchThreadID)
{
    _GridTable[id.x] = uint2(0, 0);
}

[numthreads(8, 1, 1)]
void MakeGridLookUpTable(uint3 id : SV_DispatchThreadID)
{
    int currIndex = id.x;
    int prevIndex = id.x - 1 < 0 ? _ParticleNum - 1 : id.x - 1;
    int nextIndex = id.x + 1 > _ParticleNum - 1 ? 0 : id.x + 1;
    int currGrid = _ParticleGridPair[currIndex].x;
    int prevGrid = _ParticleGridPair[prevIndex].x;
    int nextGrid = _ParticleGridPair[nextIndex].x;
    if (currGrid != prevGrid) _GridTable[currGrid].x = currIndex;
    if (currGrid != nextGrid) _GridTable[currGrid].y = currIndex;
}

[numthreads(8, 1, 1)]
void RearrangeParticle(uint3 id : SV_DispatchThreadID)
{
    int newID = _ParticleGridPair[id.x].y;
    _ParticleBuffer[id.x] = _ReadParticleBuffer[newID];
}

[numthreads(8, 1, 1)]
void Debug(uint3 id : SV_DispatchThreadID)
{
    Particle p = _ParticleBuffer[id.x];

    // assign grid id to particle color
    uint gridID = _ParticleGridPair[id.x].x;
    uint2 grid = GridIDToGrid(gridID, _GridNumX);
    p.color = float3(grid.x/(float)_GridNumX, grid.y/(float)_GridNumY, 0);

    _ParticleBuffer[id.x] = p;
}

